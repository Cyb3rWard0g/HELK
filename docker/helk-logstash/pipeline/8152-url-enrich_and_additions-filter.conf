# HELK URL enrichments and additions
# HELK build Stage: Alpha
# Author: Nate Guagenti (@neu5ron)
# License: GPL-3.0

filter {
  # URL parsing, normalization, and enrichment
  if [url_original] {

    ruby {
      code => '
        require "addressable/uri"
        url = event.get("url_original")
        url_total_paths = 0

        # Length of url
        url_length = url.length

        # Total "paths" (ie: "/")
        url_total_paths = url.split("/").length - 1
        # If url after being cleaned or originally is only "/" then we will get -1 so need to say if -1 set to 0
        if url_total_paths == -1
            url_total_paths = 1
        end

        # url Contains non ascii
        url_has_non_ascii = !url.ascii_only?

        # url Contains non whitespace
        url_has_whitespace = url.match?(/\s/)

        # URL/HTTP is a best practice and not strict.
        begin
          url_parsed = Addressable::URI.parse(url)
          url_extension = url_parsed.extname
          url_query = url_parsed.query
          url_user = url_parsed.user
          url_password = url_parsed.password
          url_scheme = url_parsed.scheme
          url_port = url_parsed.port
          url_host = url_parsed.host
          # may not exist, but want to grab these incase log/event already (has) set these
          previous_url_extension = event.get("url_extension")
          previous_url_query = event.get("url_query")
          previous_url_user = event.get("url_user_name")
          previous_url_password = event.get("url_user_password")
          previous_url_scheme = event.get("url_scheme")
          previous_url_port = event.get("url_port")
          previous_url_host = event.get("url_host_name")

          if !url_extension.nil? && !url_extension.empty? && !defined?(previous_url_extension).nil?
            event.set("url_extension", url_extension[1..-1])
          end
          if !url_query.nil? && !url_query.empty? && !defined?(previous_url_query).nil?
            event.set("url_query", url_query)
          end
          if !url_user.nil? && !url_user.empty? && !defined?(previous_url_user).nil?
            event.set("url_user_name", url_user)
          end
          if !url_password.nil? && !url_password.empty? && !defined?(previous_url_password).nil?
            event.set("url_user_password", url_password)
          end
          #if !url_scheme.nil? && !url_scheme.empty? && !defined?(previous_url_scheme).nil?
          if !url_scheme.nil? && !url_scheme.empty?
            event.set("url_scheme", url_scheme)
          end
          if !url_port.nil? && !url_port.to_s.empty? && !defined?(previous_url_port).nil?
            event.set("url_port", url_port)
          end
        rescue Addressable::URI::InvalidURIError
          # Add a value so we know there was an erroneous url
          current_tagged_log = event.get("tags")
          tagged_value = "invalid url"
          # Field exists so append
          if !defined?(current_tagged_log).nil?
            # If multiple values append to existing array
            if current_tagged_log.is_a? Enumerable
              new_tagged_log = current_tagged_log.push(tagged_value)
            # Single value so create an array
            else
              new_tagged_log = [ current_tagged_log, tagged_value ]
            end
            event.set("tags", new_tagged_log)
          # Field doesn"t exist so safe to create
          else
              event.set("tags", tagged_value)
          end
        rescue ArgumentError => e
          # Add a value so we know there was a string error
          current_tagged_log = event.get("etl_info_tags")
          tagged_value = %Q"url error: #{e.message}"
          # Field exists so append
          if !defined?(current_tagged_log).nil?
            # If multiple values append to existing array
            if current_tagged_log.is_a? Enumerable
              new_tagged_log = current_tagged_log.push(tagged_value)
            # Single value so create an array
            else
              new_tagged_log = [ current_tagged_log, tagged_value ]
            end
            event.set("tags", new_tagged_log)
          # Field doesn"t exist so safe to create
          else
            event.set("tags", tagged_value)
          end
        end

        # Set additional event parameters
        event.set("meta_url_length", url_length)
        event.set("meta_url_paths_count", url_total_paths)
        event.set("meta_url_has_non_ascii", url_has_non_ascii)
        event.set("meta_url_has_whitespace", url_has_whitespace)
      '
      tag_on_exception =>  "_rubyexception-all-url_additions"
    }

  }
}